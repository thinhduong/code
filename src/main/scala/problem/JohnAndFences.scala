package problem/*import scala.collection.mutableobject JohnAndFences {  /* case class Range(from: Int, to: Int)   val MIN_SIZE = 5   /* Divide and Conquer can't solve this problem completely, still timeout inspite of O(nlogn) */   def solve(heights: Seq[Int]): Int = {     def solve1(height: Int, heights: Seq[(Int,Int)]): Seq[Range] = {       def go(hs: Seq[(Int, Int)], acc: List[Range]): Seq[Range] = hs.dropWhile{case (h, _) => h < height } match {         case Nil => acc         case xs => {           val ys = xs.takeWhile { case(h, _) => h >= height }.map { case(_, idx) => idx }           go(xs.drop(ys.length), Range(ys.min, ys.max) :: acc)         }       }       go(heights, List())     }     def split(hs: Seq[(Int, Int)]): Seq[(Int, Range)] = {       val len = hs.length       /*if (hs.length <= MIN_SIZE) {         hs.flatMap{ case (h, _) => solve1(h, hs).map(range => (h, range)) }       } */       if (hs.length == 1) {         Seq(hs(0)._1, Range(hs(0)._2, hs(0)._2))       }       else {         val (l, r) = hs.splitAt(len / 2)         val (m1, m2) = (split(l), split(r))         TimeHelper.time {           print(s"${m1.size} and ${m2.size}")           merge1(m1, m2) }       }     }     def merge1(left: Seq[(Int, Range)], right: Seq[(Int, Range)]): Seq[(Int, Range)] = {       val lR = for{         l <- left       } yield {         val (h, rng) = l         val a = right.filter{case (rh, Range(fr, _)) => rh >= h && fr == rng.to + 1}         if (a.isEmpty) {           l         } else {           val b = a.maxBy(_._2.to)           (h, Range(rng.from, b._2.to))         }       }       val rR = for {         r <- right       } yield {         val (h, rng) = r         val a = left.filter{case (lh, Range(_, to)) => lh >= h && to == rng.from - 1}         if (a.isEmpty) {           r         } else {           val b = a.minBy(_._2.from)           (h, Range(b._2.from, rng.to))         }       }       (lR ++ rR).distinct     }     split(heights.zipWithIndex).map{ case (h, ws) => h * (ws.to - ws.from + 1) }.max   }          */  def solve2(heights: Seq[Int]): Int = {    class Block(val height: Int, var width: Int, var lastIndex: Int) {      def area = height * width    }    def go(idx: Int, acc: List[mutable.ListBuffer[Block]]): Int =  {      if (idx >= heights.size)        acc.flatten.map(_.area).max      else {        val h = heights(idx)        if (acc.isEmpty) {          val a = mutable.ListBuffer.empty[Block]          a.append(new Block(h, 1, idx))          go(idx + 1, a :: acc)        }        else {          val curLessThanH = acc.head.filter(b => b.height <= h)          if (curLessThanH.isEmpty) {            val a = mutable.ListBuffer.empty[Block]            val maxW = acc.head.toList.map(_.width).max            a.append(new Block(h, maxW + 1, idx))            go(idx + 1, a :: acc)          }          else if (curLessThanH.size == acc.head.size) {            for{              c <- curLessThanH            } yield {              c.width += 1              c.lastIndex = idx            }            if (!curLessThanH.exists(_.height == h)) {              acc.head.append(new Block(h, 1, idx))            }            go(idx + 1, acc)          }          else {            val a = mutable.ListBuffer.empty[Block]            for{              c <- curLessThanH            } yield {              a.append(new Block(c.height, c.width + 1, idx))            }            if (!curLessThanH.exists(_.height == h)) {              val maxW = acc.head.filter(_.height > h).toList.map(_.width).max              a.append(new Block(h, maxW + 1, idx))            }            go(idx + 1, a :: acc)          }        }      }    }    go(0, Nil)  }  def main(args: Array[String]): Unit = {    readInt()    val hs = readLine().split(' ').map(_.toInt)    println(solve2(hs.toList))  }}  */